use std::{error::Error, collections::HashMap};

use serde::{Deserialize, Serialize};

use crate::{hashes, utils::arr_to_bi};

use self::utils::{is_valid_tx, calculate_mining_reward};

pub mod difficulty {
    use std::{io::{Error, ErrorKind}, vec};

    use crate::utils::{bi_to_arr, arr_to_bi};

    // create a difficulty array
    pub fn create(num_zeros: usize) -> Result<[u8; 32], Error> {
        // will crash otherwise
        if num_zeros > 32 {
            return Err(Error::new(ErrorKind::Other, "num_zeros cannot exceed 32!"));
        }

        // create zeros
        let mut diff = vec![0x00_u8; num_zeros];
        // fill other bytes
        diff.append(&mut vec![0xFF_u8; 32 - num_zeros]);
        // try to convert to array
        diff.try_into()
            .map_err(|_| Error::new(ErrorKind::Other, "failed to convert vec<u8> to [u8; 32]"))
    }

    // check if the difficulty is satisfied
    // basically if the arrays were represented as a number
    // the hash has to be lower or equal to the difficulty
    pub fn satisfies(difficulty: &[u8; 32], hash: &[u8; 32]) -> bool {
        for i in 0_usize..32_usize {
            if hash[i] > difficulty[i] {
                return false;
            }

            if difficulty[i] > hash[i] {
                return true;
            }
        }
        true
    }

    // will adjust the difficulty to try to reach target block time
    pub fn adjusted(
        current: &[u8; 32], 
        time_interval: u64,
        target_time: u64,
        adjustment_interval: u32,
        precision: u32,
    ) -> [u8; 32] {
        // calculate the current ratio
        let ratio = ((target_time * adjustment_interval as u64) as f64) / (time_interval as f64);

        // convert difficulty to bigint for easier calculations
        let mut diff_bi = arr_to_bi(current);
        // divide first to avoid buffer overflow
        diff_bi /= (ratio * (10u64.pow(precision) as f64)) as u64;
        diff_bi *= 10u64.pow(precision);

        bi_to_arr(&diff_bi)
    }
}

pub mod utils {
    use std::error::Error;

    use crate::hex::ToHex;
    use crate::{script, hashes};

    use super::{Transaction, TxStore};

    pub fn hash_utxou(utxou: (&[u8; 32], &usize)) -> Result<[u8; 32], Box<dyn Error>>  {
        let mut bytes: Vec<u8> = Vec::new();
        bytes.extend(bincode::serialize(utxou.0)?);
        bytes.extend(bincode::serialize(utxou.1)?);

        Ok(hashes::sha256(&bytes)?)
    }

    pub fn is_valid_tx(tx: &Transaction, store: &TxStore) -> bool {
        let vout_total = tx.vout_total();
        let mut vin_total = 0_u128;

        // validate inputs
        for (hash, index, solution) in &tx.vin {
            // check if utxo exists
            if let Some((value, lock)) = store.get(hash, index) {
                // check if utxou is hashable
                if let Ok(utxou_hash) = hash_utxou((hash, index)) {
                    // validate script
                    if script::eval(format!(
                        "{} {} {}",
                        solution,
                        utxou_hash.to_vec().to_hex(),
                        lock
                    ))
                    .is_none() {
                        return false;
                    }

                    vin_total += value;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }

        vin_total < vout_total
    }

    pub fn add_tx_to_store(tx: &Transaction, store: &mut TxStore) {
        // remove used transaction outputs
        for (hash, index, _) in &tx.vin {
            store.remove(hash, index)
        }

        // add new utxo's
        for (index, utxo) in tx.vout.iter().enumerate() {
            store.set(&tx.hash().expect("Transaction couldn't be hashed!"), index, utxo.clone());
        }
    }

    pub fn calculate_mining_reward(
        block_height: usize, 
        halvings_interval: usize,
        start_mining_reward: u128
    ) -> u128 {
        // based on formula reward = floor( start_reward / 2^( floor(block_height / halving_interval) ) )
        // https://www.desmos.com/calculator
    
        let num_halvings = (block_height / halvings_interval) as u32;
    
        start_mining_reward / 2_i32.pow(num_halvings) as u128
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    // unique number generated by the transaction sender to identify transaction
    pub nonce: u128,

    // vector of inputs
    //
    // an input consists of:
    //  - transaction hash of the utxo
    //  - index of the utxo
    //  - solution to the utxo
    pub vin: Vec<([u8; 32], usize, String)>,

    // vector of outputs
    //
    // an output consists of:
    //  - value
    //  - lock
    pub vout: Vec<(u128, String)>,
}

impl Transaction {
    pub fn hash(&self) -> Result<[u8; 32], Box<dyn Error>> {
        let mut bytes: Vec<u8> = Vec::new();
        bytes.extend(bincode::serialize(&self.nonce)?);
        bytes.extend(bincode::serialize(&self.vin)?);
        bytes.extend(bincode::serialize(&self.vout)?);

        Ok(hashes::sha256(&bytes)?)
    }

    pub fn vout_total(&self) -> u128 {
        self.vout.iter().map(|utxo| utxo.0).sum()
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Block {
    // when was block mined
    pub timestamp: u64,

    // hash of the previous block
    pub previous: [u8; 32],

    // number with which the block satisfies the difficulty
    pub nonce: u128,

    // transactions included in the block
    pub transactions: Vec<Transaction>,
}

impl Block {
    pub fn hash(&self, nonce: Option<u128>) -> Result<[u8; 32], Box<dyn Error>> {
        let nonce = nonce.unwrap_or(self.nonce);

        let mut bytes: Vec<u8> = Vec::new();
        bytes.extend(bincode::serialize(&self.timestamp)?);
        bytes.extend(bincode::serialize(&self.previous)?);
        bytes.extend(bincode::serialize(&nonce)?);
        bytes.extend(bincode::serialize(&self.transactions)?);

        Ok(hashes::sha256(&bytes)?)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
// Blockchain stores only the vector of blocks
pub struct Blockchain(Vec<Block>);

impl Blockchain {
    pub fn new_empty() -> Self {
        Self { 0: Vec::new() }
    }

    pub fn height(&self) -> usize {
        self.0.len()
    }

    fn at(&self, i: i32) -> &Block {
        let idx: usize = if i < 0 {
            self.height() - i.abs() as usize
        } else {
            i as usize
        };
        &self.0[idx]
    }

    pub fn valid_next(
        &self, 
        block: &Block, 
        store: &TxStore, 
        difficulty: &[u8; 32], 
        block_height: usize, 
        halvings_interval: usize,
        start_mining_reward: u128
    ) -> Option<bool> {
        // validate timestamp
        // doesn't need validation if first block
        if self.0.len() > 0 && block.timestamp < (self.0.last()?).timestamp {
            return Some(false);
        }

        // validate previous
        // doesn't need validation if first block
        if self.0.len() > 0 && block.previous != (self.0.last()?).hash(None).ok()? {
            return Some(false);
        }

        // validate nonce
        if !difficulty::satisfies(&difficulty, &block.hash(None).ok()?) {
            return Some(false);
        }

        // validate transaction
        let mut coinbase_tx: Option<Transaction> = None;
        let mining_reward = calculate_mining_reward(block_height, halvings_interval, start_mining_reward);
        let mut fees = 0_u128;

        for tx in &block.transactions {
            // possible coinbase transaction
            if tx.vin.len() == 0 {
                // check if there wasn't already a coinbase transaction
                if coinbase_tx.is_some() {
                    return Some(false);
                }

                // valid coinbase transaction found
                coinbase_tx = Some(tx.clone());
                continue;
            }

            // check if transaction valid
            if !is_valid_tx(tx, store) {
                return Some(false);
            }

            // add fees
            // TODO: fees += tx.vin_total() - tx.vout_total()
        }

        // check if reward isn't too high
        if let Some(tx) = coinbase_tx {
            if tx.vout_total() > mining_reward + fees {
                return Some(false);
            }
        }

        Some(true)
    }

    // adds a block to the blockchain
    // doesn't check if the block is valid, 
    // so run valid_next(block) first
    pub fn add(&mut self, store: &mut TxStore, block: Block) {
        for tx in &block.transactions {
            utils::add_tx_to_store(tx, store);
        }

        self.0.push(block);
    }

    pub fn adjust_difficulty(
        &self, 
        difficulty: &mut [u8; 32],
        target_time: u64,
        adjustment_interval: u32,
        precision: u32,
    ) {
        if (self.height() as u32) < adjustment_interval ||
            (self.height() as u32)  % adjustment_interval != 0
        {
            return;   
        }

        let time_interval = self.at(-1).timestamp - self.at(-(adjustment_interval as i32)).timestamp;

        *difficulty = difficulty::adjusted(
            difficulty, 
            time_interval, 
            target_time, 
            adjustment_interval, 
            precision
        );
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TxStore(HashMap<String, HashMap<usize, (u128, String)>>);

impl TxStore {
    pub fn new_empty() -> Self {
        TxStore { 0: HashMap::new() }
    }

    pub fn get(&self, hash: &[u8; 32], index: &usize) -> Option<&(u128, String)> {
        self.0.get(&arr_to_bi(hash).to_string())?.get(index)
    }

    pub fn set(&mut self, hash: &[u8; 32], index: usize, utxo: (u128, String)) {
        let key = &arr_to_bi(hash).to_string();
        
        if self.0.get_mut(key).is_none() {
            self.0.insert(key.clone(), HashMap::new());
        }

        self.0.get_mut(key).expect("UNREACHABLE!").insert(index, utxo);
    }

    pub fn remove(&mut self, hash: &[u8; 32], index: &usize) {
        let key = &arr_to_bi(hash).to_string();

        if let Some(map) = self.0.get_mut(key) {
            map.remove(index);

            if map.len() == 0 {
                self.0.remove(key);
            }
        }
    }
}